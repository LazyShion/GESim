import os
from typing import List, Union
import tempfile

import numpy as np
from rdkit import Chem

from gesim import convert, gdb, graph_entropy


def graph_entropy_similarity(
    mol1: Union[Chem.Mol, str],
    mol2: Union[Chem.Mol, str],
    r: int=4,
    return_graph_entropy: bool=False,
    use_logistic_scaler: bool=True) -> float:
    """Calculate the graph entropy similarity between two molecules. The types of mol1 and mol2 must be same.

    Args:
        mol1 (Union[Chem.Mol, str]): Mol object as defined by RDKit or graph text generated by get_graph_from_mol()
        mol2 (Union[Chem.Mol, str]): Mol object as defined by RDKit or graph text generated by get_graph_from_mol()
        r (int, optional): Radius parameter of fingerprint calculation.
                           Defaults to 4.
        return_graph_entropy (bool, optional): If set to `True`, the function returns the raw graph entropy.
                                               If `False`, it returns the similarity measure, 
                                               which is 1 minus the graph entropy.
                                               Defaults to False.
        use_logistic_scaler (bool, optional): If set to `True`, the function returns the similarity measure
                                              scaled by the logistic function (L=1, k=7, x0=0.4).
                                              This scaling is to adjust the range of similarity values so that
                                              they are distributed between 0 and 1. 
                                              This option is not applied to the raw graph entropy value. 
                                              Defaults to True.

    Returns:
        float: the graph entropy similarity measure if `return_graph_entropy` is `False`.
               Otherwise, returns the graph entropy value itself.
    """
    if type(mol1) != type(mol2):
        raise TypeError("Types of mol1 and mol2 do not match.")
    mol_list = [mol1, mol2]
    with tempfile.TemporaryDirectory(prefix='gesim_') as tmpdir:
        tmp_file = os.path.join(tmpdir, 'graph.txt')
        tmp_bin_file = os.path.join(tmpdir, 'graph.bin')
        _create_graph_from_mols(mol_list, tmp_file)
        convert.convert_graph_to_binary(tmp_file, tmp_bin_file)
        db = gdb.GraphDB(tmp_bin_file)
    ge_calculator = graph_entropy.GraphEntropy(db, r)
    ge_value = ge_calculator.graph_entropy(0, 1)
    if return_graph_entropy:
        return ge_value
    similarity = 1 - ge_value
    return logistic_function_scaler(similarity, L=1, k=7, x0=0.4) if use_logistic_scaler else similarity
        

def graph_entropy_similarity_batch(
    mol_query: Union[Chem.Mol, str],
    mols: Union[List[Chem.Mol], List[str]],
    r: int=4,
    return_graph_entropy: bool=False,
    use_logistic_scaler: bool=True) -> List[float]:
    """Calculate the graph entropy similarity for a query molecule against a batch of
       molecules.

    Args:
        mol_query (Chem.Mol): Query RDKit Mol object or graph representation to be compared against the list
        mols (List[Chem.Mol]): List of RDKit Mol objects or graph representations to compare with the query molcule.
        r (int, optional): Radius parameter of fingerprint calculation.
                           Defaults to 4.
        return_graph_entropy (bool, optional): If set to `True`, the function returns the list of raw graph entropy values. 
                                               If `False`, it returns the list of the similarity measures, 
                                               which is 1 minus the graph entropy values.
                                               Defaults to False.
        use_logistic_scaler (bool, optional): If set to `True`, the function returns the similarity measure
                                              scaled by the logistic function (L=1, k=7, x0=0.4).
                                              This scaling is to adjust the range of similarity values so that
                                              they are distributed between 0 and 1. 
                                              This option is not applied to the raw graph entropy value. 
                                              Defaults to True.

    Returns:
        List[float]: List of similarity measures between the query molecule and each
                     molecule in the list if `return_graph_entropy` is `False`. If 
                     `True`, returns a list of graph entropy values for each comparison.
    """
    if type(mol_query) != type(mols[0]):
        raise TypeError("Types of mol_query and mols[0] do not match.")
    mol_list = [mol_query] + mols
    with tempfile.TemporaryDirectory(prefix='gesim_') as tmpdir:
        tmp_file = os.path.join(tmpdir, 'graph.txt')
        tmp_bin_file = os.path.join(tmpdir, 'graph.bin')
        _create_graph_from_mols(mol_list, tmp_file)
        convert.convert_graph_to_binary(tmp_file, tmp_bin_file)
        db = gdb.GraphDB(tmp_bin_file)
    ge_calculator = graph_entropy.GraphEntropy(db, r)
    ge_values = ge_calculator.graph_entropy_all(0)
    if return_graph_entropy:
        return ge_values
    similarities = [1 - x for x in ge_values]
    if use_logistic_scaler:
        similarities = [logistic_function_scaler(s, L=1, k=7, x0=0.4) for s in similarities]
    return similarities


def get_matched_mapping_numbers(
    mol1: Union[Chem.Mol, str],
    mol2: Union[Chem.Mol, str],
    r: int=4) -> List[int]:
    """Get the matched mapping numbers between two molecules. The types of mol1 and mol2 must be same.

    Args:
        mol1 (Union[Chem.Mol, str]): Mol object as defined by RDKit or graph text generated by get_graph_from_mol()
        mol2 (Union[Chem.Mol, str]): Mol object as defined by RDKit or graph text generated by get_graph_from_mol()
        r (int, optional): Radius parameter of fingerprint calculation.
                           Defaults to 4.

    Returns:
        List[int]: Return a list of lists, where each list corresponds to each molecule, 
                   with matched atoms represented by 1 and unmatched atoms by -1.
    """
    if type(mol1) != type(mol2):
        raise TypeError("Types of mol1 and mol2 do not match.")
    mol_list = [mol1, mol2]
    with tempfile.TemporaryDirectory(prefix='gesim_') as tmpdir:
        tmp_file = os.path.join(tmpdir, 'graph.txt')
        tmp_bin_file = os.path.join(tmpdir, 'graph.bin')
        _create_graph_from_mols(mol_list, tmp_file)
        convert.convert_graph_to_binary(tmp_file, tmp_bin_file)
        db = gdb.GraphDB(tmp_bin_file)
    ge_calculator = graph_entropy.GraphEntropy(db, r)
    return ge_calculator.match_mapping(0, 1)


def _create_graph_from_mols(
    mol_list: Union[List[Chem.Mol], List[str]],
    output_graph_file: str) -> None:
    """Generate graph representations of a given list of molecules and save them to a file.

    Args:
        mol_list (List[Chem.Mol]): List of RDKit Mol objects to be converted into graph
                                   representations.
        output_graph_file (str): Path to output of graph data
    """
    output_list = []
    for i, mol in enumerate(mol_list):
        if type(mol) == Chem.Mol:
            crs_graph = get_graph_from_mol(mol)
        else:  # type(mol) == str
            crs_graph = mol
        output_list.append(crs_graph.format(index=i))

    with open(output_graph_file, 'w') as f:
        f.writelines(output_list)

    
def get_graph_from_mol(
    mol: Chem.Mol) -> str:
    """_summary_

    Args:
        mol (Chem.Mol): RDKit Mol object to be converted into graph representation.

    Returns:
        str: the graph representation with index placeholder
    """
    crs_graph = ""
    crs_graph += "t {index}\n"  # placeholder
    for a in mol.GetAtoms():
        crs_graph += f"v {a.GetIdx()} {a.GetSymbol()}\n"
    for b in mol.GetBonds():
        crs_graph += f"e {b.GetIdx()} {b.GetBeginAtomIdx()} {b.GetEndAtomIdx()} {b.GetBondTypeAsDouble()}\n"
    return crs_graph


def logistic_function_scaler(x, L=1, k=1, x0=0):
    if x == 0 or x == 1:
        return x
    return L / (1 + np.exp(-k*(x-x0)))
